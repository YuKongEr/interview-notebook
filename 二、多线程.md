### 1  Java实现多线程有哪几种方式。

共四种，分别是。

- 继承Thread

继承Thread，重写它的run方法既可以创建一个线程，优点是简单，缺点就是java只支持单继承，那么意味着我们这个类就不能再去继承其他的类。实现如下

```java
public class TaskThread1 extends Thread{

    @Override
    public void run() {
        System.out.println("extend Thread");
    }

    public static void main(String[] args) {
        new TaskThread1().start();
    }
}

```

- 实现Runnable接口

通过实现Runable接口，重写它的run方法，也可以创建一个线程，它相比之前的方法是去实现接口，java支持接口的多实现，那么这样会显得更加灵活，实现如下。

```java
public class TaskRunner1 implements Runnable {
    @Override
    public void run() {
        System.out.println( " implement runnable ");
    }


    public static void main(String[] args) {
        new Thread(new TaskRunner1()).start();;
    }
}
```

- 实现Callable接口

相比于Runable，Callable是一种带返回值得方法，我们需要重写它的call方法， Callable需要与FutrueTask配合使用，通过FutureTask的get方法即可放回call方法的返回值，然后此时call方法还没执行完成，那么get方法将会被阻塞挂起。实现如下

```java
public class TaskCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String result = "implement Callable";
        return result;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> futureTask = new FutureTask<>(new TaskCallable());
        new Thread(futureTask).start();
        TimeUnit.SECONDS.sleep(3);
        System.out.println(futureTask.get());
    }
}
```

- 线程池实现

```java
public class TaskExecutor {

    public static void main(String[] args) {
        ExecutorService executorService = new ThreadPoolExecutor(10, 20,
                1000L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque<Runnable>(1024));
        for (int i = 0; i < 10; i++) {
            executorService.execute(() -> {
                System.out.println("by thread pool");
            });
        }
    }

}
```

### 2 Callable和Future的了解。

- Callable位于java.util.concurrent包下，是这个泛型接口。它也是一种实现线程的接口，继承Callable接口重写它的call方法即可，它相比于Runnable接口实现线程的优点就是它支持返回值与抛出异常。它指定的泛型就是它的返回值。

- Future也是一个接口，它用封装异步计算的结果，它有三个比较重要的方法。isDone() 判断线程是否执行完成, cancel()中断线程, get()获取线程执行完的结果，如果尚未执行则会阻塞，一直到执行完。

Callable方式的线程启动有两种方法，一种是通过线程池，一种是通过FutureTask

- 线程池，通过ExecutorService的submit方法即可提交一个Callable线程任务，它的返回值的Future。
- FutureTask，它是Future的实现类，同时它也实现了Runable接口，所以FutureTask可以通过new Thread方式启动，也可以通过线程池方式启动。

下面代码演示一下。

```java
public class TaskCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String result = "implement Callable";
        return result;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> futureTask = new FutureTask<>(new TaskCallable());
        new Thread(futureTask).start();
        TimeUnit.SECONDS.sleep(3);
        System.out.println(futureTask.get());

        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Future<String> future = executorService.submit(new TaskCallable());
        System.out.println(future.get());;
    }
}
```

