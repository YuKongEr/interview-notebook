### 1  Java实现多线程有哪几种方式。

共四种，分别是。

- 继承Thread

继承Thread，重写它的run方法既可以创建一个线程，优点是简单，缺点就是java只支持单继承，那么意味着我们这个类就不能再去继承其他的类。实现如下

```java
public class TaskThread1 extends Thread{

    @Override
    public void run() {
        System.out.println("extend Thread");
    }

    public static void main(String[] args) {
        new TaskThread1().start();
    }
}

```

- 实现Runnable接口

通过实现Runable接口，重写它的run方法，也可以创建一个线程，它相比之前的方法是去实现接口，java支持接口的多实现，那么这样会显得更加灵活，实现如下。

```java
public class TaskRunner1 implements Runnable {
    @Override
    public void run() {
        System.out.println( " implement runnable ");
    }


    public static void main(String[] args) {
        new Thread(new TaskRunner1()).start();;
    }
}
```

- 实现Callable接口

相比于Runable，Callable是一种带返回值得方法，我们需要重写它的call方法， Callable需要与FutrueTask配合使用，通过FutureTask的get方法即可放回call方法的返回值，然后此时call方法还没执行完成，那么get方法将会被阻塞挂起。实现如下

```java
public class TaskCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String result = "implement Callable";
        return result;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> futureTask = new FutureTask<>(new TaskCallable());
        new Thread(futureTask).start();
        TimeUnit.SECONDS.sleep(3);
        System.out.println(futureTask.get());
    }
}
```

- 线程池实现

```java
public class TaskExecutor {

    public static void main(String[] args) {
        ExecutorService executorService = new ThreadPoolExecutor(10, 20,
                1000L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque<Runnable>(1024));
        for (int i = 0; i < 10; i++) {
            executorService.execute(() -> {
                System.out.println("by thread pool");
            });
        }
    }

}
```

### 2 Callable和Future的了解。

- Callable位于java.util.concurrent包下，是这个泛型接口。它也是一种实现线程的接口，继承Callable接口重写它的call方法即可，它相比于Runnable接口实现线程的优点就是它支持返回值与抛出异常。它指定的泛型就是它的返回值。

- Future也是一个接口，它用封装异步计算的结果，它有三个比较重要的方法。isDone() 判断线程是否执行完成, cancel()中断线程, get()获取线程执行完的结果，如果尚未执行则会阻塞，一直到执行完。

Callable方式的线程启动有两种方法，一种是通过线程池，一种是通过FutureTask

- 线程池，通过ExecutorService的submit方法即可提交一个Callable线程任务，它的返回值的Future。
- FutureTask，它是Future的实现类，同时它也实现了Runable接口，所以FutureTask可以通过new Thread方式启动，也可以通过线程池方式启动。

下面代码演示一下。

```java
public class TaskCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        String result = "implement Callable";
        return result;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> futureTask = new FutureTask<>(new TaskCallable());
        new Thread(futureTask).start();
        TimeUnit.SECONDS.sleep(3);
        System.out.println(futureTask.get());

        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Future<String> future = executorService.submit(new TaskCallable());
        System.out.println(future.get());;
    }
}
```

### 3  线程池的参数有哪些，在线程池创建一个线程的过程

- corePoolSize    				核心线程数
- maximumPoolSize                       最大线程数
- keepAliveTime                               非核心线程存活时间
- timeUnit                                          时 间单位
- blockQueue                                     任务阻塞队列
- threadFactory                                  线程工厂
- RejectedExecutionHandler             拒绝策略

### 4 volatile关键词的作用，原理

volatile它的内存语义就是每当线程去写一个volatile变量的时候，它会将本地内存的共享变量重新写回到主内存。

那么每当线程去读一个volatile变量的时候，它会将本地内存的共享变量置为无效，并且重新从主内存读取。

volatile它可以保证`可见性`与`一定有序性`那么根据它的特点，它可以被用于线程之间的通信与双重检测机制，

被volatile修饰过的变量，在编译后字节码前后会插入内存屏障。

- 对于volatile写 前会插入 storestore屏障，保证volatile写不跟之前的普通写的重排序
- 对于volatile写 后会插入storeload屏障，保证volatile写不会跟之后的volatile写/读(如果有)重排序
- 对于volatile读 后会插入loadload屏障， 保证volatile读不会跟之后的普通读重排序
- 对于volatile读 后会插入loadstore屏障，保证volatile读不会跟之后的普通写重排序

### 5 synchronized关键词的用法，优缺点

synchronized 是通过对象监视器来实现的，对象监视器是一种互斥锁，意味着同时只能有一个线程获取到这个对象的锁。

synchronized代表同步，它可以修饰方法，它也可以修饰代码块。

- 如果synchronized修饰的普通方法 那么它锁的当前对象
- 如果synchronized修饰的静态方法 那么它锁的当前类的class对象

       同理在同步代码块中synchronized锁的是类的普通成员变量，那么它锁的就是当前对象，

如果是静态变量或者是class对象，那么它锁的是类的class对象。

优点：实现简单，语义清晰，便于JVM堆栈跟踪，加锁与解锁的过程由jvm自动控制，在jdk1.6后，通过了多种优化方案，使用广泛。

缺点： 悲观的排它锁，不能进行高级功能。